### A Отчислительно-восстановительный процесс
Ваша задача — написать класс университета, который будет поддерживать операции зачисления и отчисления студентов, а также операции вывода текущего списка студентов и расчёта среднего возраста студентов.

Для начала создайте класс Student, в котором будет три поля: имя студента (name), его возраст (age) и курс (course). Напишите конструктор, в который будут передаваться все три необходимых значения. Напишите аннотации типов аргументов конструктора.

Далее создайте класс University. Конструктор университета не имеет параметров, внутри себя инициализирует приватный словарь студентов, ключом которого является имя студента, а значением — объект типа Student. Напомним, что по используемому стайл гайду названия приватных полей и методов классов мы начинаем c единственного символа "_", например, "_students". Напишите также аннотацию типа для этого словаря.

В классе University должно быть три обычных и два статических метода, описанных ниже. Для всех методов напишите аннотации типов входных аргументов и возвращаемых значений (в том числе для тех, которые ничего не возвращают).

Метод enroll_student принимает на вход параметры name, age, course и зачисляет соответствующего студента в университет. Если студент с таким именем уже есть, то нужно выбросить исключение RuntimeError с текстом ошибки в формате "Student with name {name} is already enrolled".

Метод expell_student принимает на вход параметр name и отчисляет соответствующего студента. Если студент с именем name не числится в университете, то необходимо выбросить исключение типа KeyError с текстом ошибки "Student with name {name} is not enrolled". Для удаления объекта из словаря предпочтительнее использовать метод pop вместо del.

Метод get_students возвращает список студентов (list объектов типа Student), отсортированных по имени в алфавитном порядке.

Статический метод print_students принимает на вход список студентов и выводит его в стандартный поток вывода в формате "Name: {student.name}, age: {student.age}, course: {student.course}".

Статический метод average_age принимает на вход список студентов и возвращает их средний возраст.

Данная задача тестируется путём выполнения кода, записанного во входном файле теста. Для работы этих тестов в функции main вызовите exec(sys.stdin.read()). Не забудьте импортировать модуль sys.

### B Это норма
Реализуйте абстрактный класс (используя модуль abc) NormalForm, от которого наследуются классы DNF и CNF. Класс NormalForm должен содержать:
* конструктор;
* метод add_clause для добавления клауз (дизъюнктов или конъюнктов);
* статический метод check_values, проверяющий корректность переданного словаря со значениями переменных;
* абстрактный метод __call__, принимающий на вход значения переменных и вычисляющий значение нормальной формы на заданном наборе, который должен быть перегружен в классах DNF и CNF.

В конструкторе NormalForm инициализируйте список клауз пустым списком. Каждая клауза является списком целых чисел — номеров переменных с положительным или отрицательным знаком. Например, число 2 кодирует переменную x2, а число -3 — отрицание переменной x3, т.е. ~x3. В методе add_clause выполните проверку, что каждый элемент списка не равен нулю, в противном случае выбросите исключение ValueError с текстом ошибки "Variable number is 0".

В статическом методе check_values выполните следующие проверки:
1. Если ключ словаря меньше 1, выбросите исключение ValueError("Key is less than 1")
2. Если значение по ключу не принадлежит множеству {0, 1}, выбросите исключение ValueError("Value should be 0 or 1")

Отнаследуйте классы DNF и CNF от класса NormalForm, в конструкторе производных классов вызовите конструктор базового класа. Перегрузите методы __call__ таким образом, чтобы он соответствовал вычислению ДНФ и КНФ при заданных значениях переменных. В самом начале метода __call__ вызовите проверку check_values из базового класса. Если при вычислении значений клауз некоторая переменная не найдена в словаре, породите исключение ValueError(f"Variable {var_num} is not found"), где var_num — номер переменной, которая не была найдена в словаре, переданном в метод __call__.

Данная задача тестируется путём выполнения кода, записанного во входном файле теста. Для работы этих тестов в функции main вызовите exec(sys.stdin.read()). Не забудьте импортировать модуль sys.

Замечание: не забывайте везде, где нужно, писать аннотации типов!
### C Сокровища кафедры
Model-View-Controller (MVC) — это шаблон проектирования, в котором данные приложения и управляющая логика разделяется на три отдельных компонента: модель (Model), представление (View) и контроллер (Controller) — таким образом, что модификация каждого компонента может осуществляться независимо.

Model предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.
View отвечает за отображение данных модели пользователю, реагируя на изменения модели.
Controller интерпретирует действия пользователя, оповещая модель о необходимости изменений.

Более подробно о паттерне проектирования MVC можно почитать в Википедии, на Хабре и любом другом Интернет-ресурсе, где есть соответствующие статьи.

А теперь попробуем с помощью паттерна MVC решить следующую задачу. Бытует легенда, что на кафедре математической кибернетики спрятаны сокровища Лупанова, и находятся они в кабинете 590 уже в течение нескольких десятилетий. Никто не знает, что именно сохранил там Олег Борисович, но есть предположение, что клад нужно искать под старым советстким паркетом.

На вход программе подаётся карта кабинета 590 в следующем формате. В первой строке заданы размеры комнаты N и M: длина и ширина. Далее, в следующей строке, содержится одно число T — количество спрятанных сокровищ О. Б. Лупанова. В следующих T строках заданы координаты сокровищ. Затем во входном файле содержится информация о проводимых археологических исследованиях, т.е. вскрытиях паркета. Сначала задано числое E — количество вскрытий, далее в E строках содержатся координаты точек, в которых они производились. Координаты точек нумеруются с нуля.

Вскрытия паркета производятся последовательно. После каждого вскрытия нужно вывести текущую карту местности в следующем формате:
X$...
..XX$
..X$.
Здесь "." — это точка, в которой ещё не проводились исследования, X — посмотрели и ничего не нашли, $ — обнаружили клад. После вывода каждой карты кафедры нужно вывести ещё пустую строку.

Для решения этой задачи сделайте следующее. Создайте класс Model, в котором будут храниться данные, т.е. текущая карта местности. У класса Model должны быть: конструктор без параметров, внутри которого инициализируется пустой объект типа list[list[Cell]], где Cell — некоторый тип ячейки (удобно сделать его как enum); метод initialize, принимающий на вход размеры кабинета 590 и инициализирующий карту нужного размера; метод add_treasure, на вход которого подаются координаты сокровища, он будет вызываться из контроллера при чтении карты; метод examine, принимающий координаты точки, в которой проводятся исследования.

Также создайте класс View для отображения карты. В этой задаче у класса View конструктор не обязателен, достаточно завести только метод print, принимающий на вход карту типа list[list[Cell]], и печатающий её в стандартный поток вывода. Для удобства в классе Cell можно переопределить метод __str__, чтобы вместо индексов enum'а сразу выводить нужные символы.

Создайте класс Controller. В конструкторе этого класса создайте объекты типа Model и View. У класса Controller должно быть два метода: read_map (чтение карты) и do_examinations (выполнение исследований). Оба этих метода производят чтение соответствующей части входных данных и взаимодействуют с моделью и представлением.

В основной функции main программы должно быть три строчки: создание Controller, вызов метода read_map, вызов метода do_examinations. Вся основная логика пишется в классах Model, View и Controller.
### D Первая пара
Фабричный метод — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. Фабричный метод позволяет классу делегировать создание подклассов. Используется, когда: Классу заранее неизвестно, объекты каких подклассов ему нужно создавать.
Класс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.
Класс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя.

Более подробно о паттернах проектирования Фабричный метод, Фабрика и Абстрактная фабрика можно почитать в Википедии, на Хабре и любом другом Интернет-ресурсе, где есть соответствующие статьи.

А мы с вами попробуем решить не очень сложную задачу паттерн Фабричный метод, в которой не будет отдельной иерархии классов для фабрики, а фабричный метод мы напишем в базовом классе иерархии конструируемых классов.

Представьте себе такую ситуацию. Николай Юрьевич Капустин поставил лекцию по функциональному анализу первой парой. Некий студент В. решил один раз за семестр пожертвовать сном и всё-таки посетить лекцию по функану. Но понять, о чём же рассказывал Николай Юрьевич, ему не удалось — он уснул прямо на занятии, лёжа на первой парте. Во сне студент В. увидел многомерное пространство, в котором находились два многомерных кочана капусты. Его заинтересовало, чему равно евклидово и манхэттенское расстояние между кочанами. Но так как во сне мозг функционирует немного иначе, вычислить эти расстояния никак не удавалось. Помогите студенту В., напишите программу, считающую евклидово и манхэттенское расстояние между двумя многомерными векторами.

На вход программе в первой строке подаётся название метрики, которую необходимо вычислить: euclidean или manhattan. Далее, в следующих двух строках, задаются два вектора одинаковой размерности. Требуется вывести расстояние между векторами по заданой метрике.

Для решения этой задачи необходимо использовать шаблон проектирования Фабличный метод. Создайте базовый класс MetricBase с абстрактным методом calculate, принимающим на вход два вектора типа list[float], который вычисляет расстояние между векторами. Отнаследуйте от него два класса EuclideanMetric и ManhattanMetric, напишите в них конкретные реализации метода calculate. Далее в базовом классе MetricBase сделайте статический фабричный метод create, который принимает на вход строку euclidean или manhattan и конструирует объект нужного класса. Чтобы не дублировать код чтения вектора, заведите функцию read_vector, возвращающую list[float].

Замечания: во всех функциях calculate, create, read_vector должны быть быть аннотации типов входных аргументов и возвращаемых значений; в функции create используйте конструкцию match / case; в конкретных реализациях методов calculate используйте zip, sum и generator expression; функцию read_vector реализуйте в одну строчку, используя map или list comprehension.

### E Нерезиновая
Стратегия — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Стратегия позволяет менять выбранный алгоритм во время выполнения программы.

Более подробно о паттерне проектирования Стратегия можно почитать в Википедии, на Хабре и любом другом Интернет-ресурсе, где есть соответствующие статьи.

А теперь — задачка. Мэр города М. снова решил расширить границы своего влияния. Для этого он решил застроить ранее неизведанные территории различными объектами, присоединив их к городу М.

Изначально в бюджете города М. есть определённая сумма денег, которую можно потратить на строительство. Каждый построенный объект приносит прибыль, которая может использоваться для дальнейшего строительства. Объекты строятся последовательно, после строительства каждого объекта все построенные объекты приносят прибыть, в том числе только что построенный объект.

Кроме того, каждый объект обладает некоторой площадью. Задача мэра — максимизировать площадь застройки. Для решения это задачи он решил использовать следующий подход. Первые несколько лет он будет строить объекты, максимизирующие прибыль. А уже потом планируется застройка, максимизирующая площадь. Итого получаем две стратегии, которые более детально описаны ниже.

Стратегия 1 (прибыль). Среди всех объектов выбираем тот, у которого отношение прибыли к стоимости строительства максимальное. Если таких объектов несколько выбираем тот, у которого отношение площади к стоимости максимальное. Если же и таких объектов несколько, то выбираем тот, у которого наибольшая прибыль.

Стратегия 2 (площадь). Среди всех объектов выбираем тот, у которого отношение площади к стоимости строительства максимальное. Если таких объектов несколько выбираем тот, у которого отношение прибыли к стоимости максимальное. Если же и таких объектов несколько, то выбираем тот, у которого наибольшая прибыль.

Как можно заметить, эти стратегии отличаются только порядком сравнения первых двух параметров (прибыль / стоимость и площадь / стоимость).

На вход программе в первой строке подаётся 2 числа: изначальное количество денег в бюджете на застройку новых территорий M, количество возможных для строительства объектов N. В следующих N строках определяются параметры объектов застройки: стоимость строительства, прибыль, площадь. И, наконец, в последней строке заданы два числа: сколько объектов строится, используя стратегию 1, а сколько — используя стратегию 2.

Для каждого построенного объекта требуется вывести его параметры (стоимость, прибыль, площадь), текущее количество денег в бюджете, текущую прибыль и площадь. Формат вывода смотрите в примерах ниже.

Каждый объект можно построить ровно один раз. Если в какой-то момент невозможно построить ни один из объектов по причине нехватки денег, строительство пропускается (выводить в этом случае ничего не нужно).

Для решения задачи используйте паттерн проектирования Стратегия. Определите класс объекта Object с параметрами cost, income, square. Создайте базовый абстрактный класс StrategyBase и два его наследника StrategyIncome и StrategySquare, соответствующие стратегиям оптимизации прибыли и площади. Создайте также класс контекста Context, конструктор которого принимает на вход стратегию, а также который имеет метод set_strategy для смены стратегии во время выполнения программы. В основной функции main должно происходить примерно следующее: создаётся класс контекста со стратегией StrategyIncome, вызывается несколько раз метод строительства, затем меняется стратегия на StrategySquare при помощи вызова set_strategy, далее опять вызывается нужно количество раз метод строительства.

Замечания: постарайтесь не дублировать код, например, в StrategyBase может быть какая-то общая реализации метода select выбора объекта, а абстрактным методом являться только метод сравнения двух объектов compare; не забывайте про аннотации типов; если у вас возникло ощущение, что формулировка задачи чем-то похожа на настольную игру "Пэчворк", то вы не ошиблись, хотя в этой задаче было сделано упрощение, в оригинальной игре кроме стоимости, прибыли и площади у тайлов есть ещё геометрия и параметр времени.
